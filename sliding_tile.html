<!DOCTYPE html>

<html>

<head><title>Sliding Tile Puzzle by TigerhawkT3</title>
<meta name='viewport' content='width=device-width'></head>

<body>
<video loop id='video' style='display: none;'></video>
<img id='image' style='display: none;' />
<input type='file' multiple id='chooser' accept='video/*,image/*' style='border: 1px solid black; border-radius: 4px; margin-bottom: 4px; font-size: 1em;' />
<a href='index.html' title='Home' style='font-size: 1.25em; text-decoration: none;'>&#x1F3E0;</a>
<a href='https://www.paypal.me/TigerhawkT3' title='Donate' style='font-size: 1.25em; text-decoration: none;'>&#x1F4B8;</a>
<br>
<textarea style='vertical-align: top; box-sizing: border-box; margin-bottom: 5px; width: 50vw;' id='textarea' placeholder='Replays and URLs here' rows='1'></textarea>
<br>
<div style='white-space: nowrap; display: flex; flex-direction: row; align-items: end; overflow-X: auto;' id='ribbon'></div>
<button name='video_control' onclick='skip(-1)'
    style='display: none; vertical-align: bottom; height: 2em; margin-bottom: 1px;' title='skip back'>&#x21B6;</button>
<button name='video_control' onclick='toggle_playback()'
    style='display: none; vertical-align: bottom; height: 2em; margin-bottom: 1px;' title='play/pause'>&#x23EF;</button>
<button name='video_control' onclick='skip(1)'
    style='display: none; vertical-align: bottom; height: 2em; margin-bottom: 1px;' title='skip forward'>&#x21B7;</button>
<button style='height: 2em; margin-bottom: 1px;' title='choose random' onclick='choose_random()'>Random</button>
Cols: <input type='number' id='columns' step='1' value='3'
 title='set one dimension below 3 to autoselect for square tiles' style='width: 2em;' />
Rows: <input type='number' id='rows' step='1' value='3'
 title='set one dimension below 3 to autoselect for square tiles' style='width: 2em;' />
Labels: <input type='checkbox' id='labels' title='include a numbered label on each tile' />
<button style='height: 2em; margin-bottom: 1px;' title='import replay or add from URL in text area' onclick='import_()'>Import</button>
<button style='height: 2em; margin-bottom: 1px;' title='export replay to text area' onclick='export_replay()'>Export</button>
<br>
<button name='replay_control' id='replay_reverse' title='toggle replay reverse' onclick='toggle_replay(-1)'
    style='display: none; height: 2em; width: 2.5em; margin-bottom: 1px; vertical-align: bottom'>&#x25C0;</button>
<button name='replay_control' id='replay_step_back' title='step replay backward' onclick='replay(-1)'
    style='display: none; height: 2em; margin-bottom: 1px; vertical-align: bottom'>&#8592;</button>
<button name='replay_control' id='replay_step_forward' title='step replay forward' onclick='replay(1)'
    style='display: none; height: 2em; margin-bottom: 1px; vertical-align: bottom'>&#8594;</button>
<button name='replay_control' id='replay_forward' title='toggle replay forward' onclick='toggle_replay(1)'
    style='display: none; height: 2em; width: 2.5em; margin-bottom: 1px; vertical-align: bottom'>&#x25B6;</button>
<span name='replay_control' id='tracker' style='display: none; height: 2em; margin-bottom: 1px;'></span><br name='replay_control' style='display: none;'>
<input type='range' name='replay_control' id='range' title='replay timeline' style='display: none; width: 95vw; margin-bottom: 1px;'></input>
<canvas id="canvas" style='border: 1px solid black; max-height: 95vh; max-width: 95vw; margin-top: 5px;'></canvas>

<script>

let canvas = document.getElementById('canvas');
let ctx = canvas.getContext("2d");
let video = document.getElementById('video');
let image = document.getElementById('image');
let column_field = document.getElementById('columns');
let row_field = document.getElementById('rows');
let labels = document.getElementById('labels');
let textarea = document.getElementById('textarea');
let tracker = document.getElementById('tracker');
let range = document.getElementById('range');
let ribbon = document.getElementById('ribbon');
let replay_step_back = document.getElementById('replay_step_back');
let replay_step_forward = document.getElementById('replay_step_forward');
let replay_reverse = document.getElementById('replay_reverse');
let replay_forward = document.getElementById('replay_forward');
let step_size;
let source;
let columns;
let rows;
let autoselect;
let board;
let starting_board;
let movelist;
let movelist_idx;
let replaying;
let range_going;
let next_move;
let now;
let total_time;
let tile_h;
let tile_w;
let blank_ID;
let success = false;
let animation_handle;

// https://stackoverflow.com/a/12646864/2617068 because JS has no built-in random.shuffle()
function shuffleArray(array) {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
    }
}
function rand_idx(sequence) { // pick a random index in a sequence
    return Math.floor(Math.random() * sequence.length);
}
function choose_random() {
    if (ribbon.children.length) ribbon.children[rand_idx(ribbon.children)].lastChild.onclick();
}
function lay_tiles(a, b) { // a and b are optional, to eliminate unnecessary drawImage calls
    if (success) ctx.drawImage(source, 0, 0, source.width, source.height, 0, 0, canvas.width, canvas.height);
    else for (let idx = 0; idx < board.length; ++idx) { // go through the board
        sx = (board[idx] % columns) * source.width/columns; // cell's contents indicate source location
        sy = Math.floor(board[idx] / columns) * source.height/rows;
        dx = (idx % columns) * tile_w; // cell's index indicates destination location
        dy = Math.floor(idx / columns) * tile_h; // next, handle blank tile (or draw tile)
        if (board[idx] === blank_ID && !success) {
            for (let i = 1; i > 0.5; i -= 0.01) { // fill progressively smaller rects
                ctx.fillStyle = '#' + Math.round((i-0.5)*255).toString(16).padStart(2, '0').repeat(3);
                ctx.fillRect(dx + (1-i)*tile_w, dy + (1-i)*tile_h, (2*i-1)*tile_w, (2*i-1)*tile_h);
            }
        }
        else if (idx===a || idx===b || a===b) // floor and ceil remove seams from rounding
            ctx.drawImage(source, Math.floor(sx), Math.floor(sy), Math.ceil(source.width/columns), Math.ceil(source.height/rows),
                                  Math.floor(dx), Math.floor(dy), Math.ceil(tile_w), Math.ceil(tile_h));
        if (labels.checked) { // draw numbering labels
            let factor = canvas.width/canvas.clientWidth;
            ctx.fillStyle = '#FFFFFF';
            ctx.fillRect(dx, dy, 30*factor, 20*factor);
            ctx.fillStyle = '#000000';
            ctx.font = 20 * factor + 'px sans-serif';
            ctx.fillText(board[idx]+1, dx+2*factor, dy+18*factor);
        }
    }
}
function make_segments() {
    success = false;
    board = []; // just a vector, not 2D
    movelist = [];
    now = Date.now();
    for (let element of document.getElementsByName('replay_control'))
        element.style['display'] = 'none';
    for (let i=0; i<rows*columns; ++i) board.push(i); // persistent ID for shuffle and win check
    blank_ID = board.pop();
    /* I specifically want the "missing" tile to be from the bottom right,
       to make it more visually pleasing to gradually solve the puzzle.
       and since that's known, the blank might as well also start at the bottom right */
    shuffleArray(board);
    /* now we count inversions.
       http://www.cs.bham.ac.uk/~mdr/teaching/modules04/java2/TilesSolvability.html
       an inversion is when a tile with a larger ID comes before a tile with
       a smaller ID - their order is "inverted." This is a factor in
       whether a given puzzle is solvable. */
    let inversions = 0;
    for (let tile = 0; tile < board.length; ++tile)
        for (let subsequent = tile; subsequent < board.length; ++subsequent)
            if (board[tile] > board[subsequent]) ++inversions;
    /* based on the way the blank tile is always the 'last' one, in the
       lower-right corner, we need an even number of inversions if we want
       this to be solvable. if it's odd, swap the last two elements */
    if (inversions % 2 === 1) [board[board.length-1], board[board.length-2]] = board.slice(-2);
    board.push(blank_ID); // don't forget to add the blank tile back after shuffling
    starting_board = board.slice(0);
    tile_h = canvas.height/rows;
    tile_w = canvas.width/columns;
}
function start_moving(event) {
    if (success) return;
    event.preventDefault();
    canvas.onmousemove = move;
    move(event);
}
function start_touch(event) {
    if (success) return;
    event.preventDefault();
    canvas.ontouchmove = move;
    move(event);
}
function move(event) {
    if (success) return; // don't move after winning
    event.preventDefault();
    if (!(event.clientX && event.clientY)) { // jury-rig the correct offset, mock touch to mouse event
        let r = canvas.getBoundingClientRect();
        event.offsetX = event.targetTouches[0].clientX - r.left;
        event.offsetY = event.targetTouches[0].clientY - r.top;
    }
    // these max/min are necessary because the event coords can be outside the canvas, e.g. -1
    let x = Math.floor(columns * Math.max(0,
            Math.min(canvas.clientWidth-2, event.offsetX)) /
            canvas.clientWidth); // calculate clicked xy tile coords
    let y = Math.floor(rows * Math.max(0,
            Math.min(canvas.clientHeight-2, event.offsetY)) /
            canvas.clientHeight);
    let tile_idx = y * columns + x; // calculate corresponding index in board
    for (let [a, b] of [[-1, 0], [1, 0], [0, -1], [0, 1]]) { // neighbor tile locations
        // check that the neighbor is actually on the board, as the index calculation wouldn't complain
        if (!(0 <= x+a && x+a < columns && 0 <= y+b && y+b < rows)) continue;
        neighbor_idx = (y+b) * columns + (x+a); // calculate corresponding index in board
        if (board[neighbor_idx] === blank_ID) { // swap to that spot
            swap(tile_idx, neighbor_idx);
            movelist.push([Date.now()-now, tile_idx, neighbor_idx]);
            now = Date.now();
            break;
        }
    }
}
function swap(a, b) {
    [board[a], board[b]] = [board[b], board[a]];
    let flag = true; // assume success, then check for otherwise...
    // but use a separate flag due to concurrency anxiety
    for (let idx = 0; idx < board.length; ++idx) if (idx !== board[idx]) {
        flag = false;
        break;
    }
    success = flag;
    lay_tiles(a, b);
}
function import_() {
    textarea.value.startsWith('[') ? import_replay() : add_media(textarea.value);
}
function import_replay() {
    if (!source) {
        alert('Start a puzzle (load media and "go") before loading a replay.');
        return;
    }
    [columns, rows, board, movelist] = JSON.parse(textarea.value);
    starting_board = board.slice(0);
    for (let element of document.getElementsByName('replay_control'))
        element.style['display'] = 'inline';
    movelist_idx = 0;
    now = Date.now();
    total_time = movelist.reduce((a,b) => a+b[0], 0);
    range.max = movelist.length;
    row_field.value = rows;
    column_field.value = columns;
    tile_h = canvas.height/rows;
    tile_w = canvas.width/columns;
    blank_ID = board.length-1;
    success = false;
    refresh_replay_controls();
    lay_tiles();
}
function refresh_replay_controls () {
    replay_step_back.disabled = !movelist_idx || replaying;
    replay_step_forward.disabled = movelist_idx >= movelist.length || replaying;
    replay_reverse.disabled = !movelist_idx;
    replay_reverse.innerHTML = replaying ? '&#x23F8;' : '&#x25C0;';
    replay_forward.disabled = movelist_idx >= movelist.length;
    replay_forward.innerHTML = replaying ? '&#x23F8;' : '&#x25B6;';
    range.disabled = replaying;
    if (!range_going) range.value = movelist_idx;
    tracker.innerHTML = movelist_idx === movelist.length ?
        `${columns}x${rows} ` + (success ? 'completed ' : '') + 'with ' +
        `${movelist.length} moves ` + 'in ' +
        `${(total_time/1000).toFixed(3)} seconds.` :
        movelist_idx + '/' + (movelist.length) + '. Move ' + (movelist_idx+1) + ': tile ' + (board[movelist[movelist_idx][1]]+1) +
        ', spot ' + (movelist[movelist_idx][1]+1) + ' to ' + (movelist[movelist_idx][2]+1) + 
        ' in ' + (movelist[movelist_idx][0]/1000).toFixed(3) + ' seconds.';
}
function range_go() {
    range_going = true;
    let direction = range.value - movelist_idx > 0 ? 1 : -1;
    for (let i = movelist_idx; i != range.value; i += direction)
        replay(direction);
    range_going = false;
}
function export_replay() {
    textarea.value = JSON.stringify([columns, rows, starting_board, movelist]);
}
function toggle_replay(direction) {
    replaying = !replaying;
    refresh_replay_controls();
    if (replaying) replay(direction);
    else clearTimeout(next_move);
}
function replay(direction) {
    if (movelist_idx + direction < 0 || movelist_idx + direction > movelist.length) {
        replaying = false;
        return;
    }
    if (direction === 1) {
        swap(...movelist[movelist_idx].slice(1));
        movelist_idx += direction;
    }
    else {
        movelist_idx += direction;
        swap(...movelist[movelist_idx].slice(1));
    }
    if (replaying && movelist_idx + direction >= 0 && movelist_idx + direction <= movelist.length)
        next_move = setTimeout(replay, movelist[movelist_idx][0], direction);
    else replaying = false;
    refresh_replay_controls();
}
function stop_moving(event) {
    canvas.onmousemove = null;
}
function stop_touch(event) {
    canvas.ontouchmove = null;
}
function toggle_playback() {
    video.paused ? video.play() : video.pause();
}
function skip(direction) { // a skip that loops around, and scales with duration
    let target = video.currentTime + direction * step_size;
    video.currentTime = target < 0 ? target + video.duration : target % video.duration;
}
function step() { // update the canvas when a video proceeds to next frame
    lay_tiles();
    animation_handle = video.requestVideoFrameCallback(step);
}
function autoselect_dimensions(small, width, height) {
    let ratio = Math.max(width, height) / Math.min(width, height);
    let big = Math.round(small * ratio);
    if (width > height) [columns, rows] = [big, small];
    else [rows, columns] = [big, small];
}
function drop_file(event) { // open the dropped file
    event.preventDefault();
    chooser.files = event.dataTransfer.files;
    choose_file({'target':{'files':event.dataTransfer.files}});
}
function choose_file(event) { // open the chosen file
    for (let file of event.target.files)
        add_media(URL.createObjectURL(file), video.canPlayType(file.type) ? 'video' : 'img');
}
function add_media(obj_url, kind) {
    // add to ribbon
    if (kind !== 'video' && kind !== 'img')
        kind = obj_url.toLowerCase().endsWith('mp4') ||
        obj_url.toLowerCase().endsWith('webm') ||
        obj_url.toLowerCase().endsWith('ogg') ? 'video' : 'img';
    ribbon.innerHTML += "<div style='text-align: center; vertical-align: bottom;'><" +
        kind + " src='" + obj_url + "' style='max-height: 4em; max-width: 4em;'>" +
        (kind === 'video' ? '</video>' : '') +
        "<br><button title='remove' onclick='this.parentElement.remove()'>del</button>" +
        "<button title='go' onclick='start_media(\"" + obj_url + '", "' + kind + "\")'>go</button></div>";
}
function start_media(obj_url, kind) {
    rows = parseInt(row_field.value);
    columns = parseInt(column_field.value);
    autoselect = false;
    if (rows < 3 && columns < 3) rows = columns = 3;
    else if (rows < 3 || columns < 3) autoselect = true;
    (kind === 'video' ? start_video : start_img)(obj_url);
}
function start_video(obj_url) {
    image.src = '';
    video.src = obj_url;
    video.onloadeddata = setdims;
    for (let element of document.getElementsByName('video_control'))
        element.style['display'] = 'inline';
}
function make_dims(w, h) { // prevent overly-large dimensions that may affect performance
    let vw = Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0); // https://stackoverflow.com/a/8876069
    let vh = Math.max(document.documentElement.clientHeight || 0, window.innerHeight || 0);
    let ratio = w/h;
    h = Math.min(Math.min(w, 2*vw)/ratio, 2*vh);
    return [Math.floor(h*ratio), Math.floor(h)];
}
function setdims() { // setup after loading a video
    if (autoselect) autoselect_dimensions(Math.max(rows, columns), video.videoWidth, video.videoHeight);
    [canvas.width, canvas.height] = make_dims(video.videoWidth, video.videoHeight);
    make_segments();
    source = video;
    [source.width, source.height] = [source.videoWidth, source.videoHeight];
    step_size = Math.log10(video.duration)**2.5;
    labels.onclick = function() {lay_tiles()}; // necessary wrapper
    video.cancelVideoFrameCallback(animation_handle);
    step();
    video.play();
}
function start_img(obj_url) {
    video.src = '';
    image.src = obj_url;
    video.onplay = null;
    video.onloadeddata = null;
    waitForImageToLoad(image).then(()=>{
        if (autoselect) autoselect_dimensions(Math.max(rows, columns), image.width, image.height);
        [canvas.width, canvas.height] = make_dims(image.width, image.height);
        make_segments();
        source = image;
        lay_tiles();
        labels.onclick = function() {lay_tiles()}; // necessary wrapper
    });
    for (let element of document.getElementsByName('video_control'))
        element.style['display'] = 'none';
}
function waitForImageToLoad(imageElement){
  return new Promise(resolve=>{imageElement.onload = resolve});
}
canvas.ondrop = drop_file;
textarea.ondrop = drop_file;
canvas.ondragover = canvas.ondragenter = function(evt) {
  evt.preventDefault();
}
chooser.onchange = choose_file;
range.oninput = range_go;
canvas.onmousedown = start_moving;
canvas.ontouchstart = start_touch;
document.onmouseup = stop_moving;
document.ontouchend = stop_touch;
</script>
</body>

</html>