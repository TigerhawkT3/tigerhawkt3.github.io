<!DOCTYPE html>

<html>

<head><title>Sliding Tile Puzzle by TigerhawkT3</title>
<meta name='viewport' content='width=device-width'></head>

<body style='font-size: 1em;'>
<video loop id='video' style='display: none;' /></video>
<img id='image' style='display: none;' />
<input type='file' id='chooser' accept='video/*,image/*' style='border: 1px solid black; margin-bottom: 2px; font-size: 1em;' />
<br />
<input style='font-size: inherit;' type='text' id='address' placeholder='Enter URL...'  />
<button style='font-size: inherit;' title='load video' onclick='choose_URL("video")'>&#x1F3A5;</button>
<button style='font-size: inherit;' title='load video' onclick='choose_URL("image")'>&#x1F4F7;</button>
<button id='play_button' onclick='toggle_playback()'
    style='display: none; font-size: inherit;' title='play/pause'>&#x23EF;</button>
<br />
Cols: <input type='number' id='columns' step='1' value='3'
 title='set one dimension below 3 to autoselect for square tiles' style='width: 2.5em;' />
Rows: <input type='number' id='rows' step='1' value='3'
 title='set one dimension below 3 to autoselect for square tiles' style='width: 2.5em;' />
Labels: <input type='checkbox' id='labels' title='include a numbered label on each tile' />
<a href='index.html' title='Home' style='font-size: 1.25em; text-decoration: none;'>&#x1F3E0;</a> | <a
    href='https://www.paypal.me/TigerhawkT3' title='Donate' style='font-size: 1.25em; text-decoration: none;'>&#x1F4B8;</a>
<br />
<canvas id="canvas" style='border: 1px solid black; max-height: 95vh; max-width: 95vw; margin-top: 5px;'></canvas><br />

<script>

let canvas = document.getElementById('canvas');
let ctx = canvas.getContext("2d");
let video = document.getElementById('video');
let image = document.getElementById('image');
let play_button = document.getElementById('play_button');
let column_field = document.getElementById('columns');
let row_field = document.getElementById('rows');
let labels = document.getElementById('labels');
let address = document.getElementById('address');
let source;
let columns;
let rows;
let autoselect;
let board;
let tile_h;
let tile_w;
let blank_ID;
let success = false;
let animation_handle;

// https://stackoverflow.com/a/12646864/2617068 because JS has no built-in random.shuffle()
function shuffleArray(array) {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
    }
}
function lay_tiles() {
    if (success) ctx.drawImage(source, 0, 0, canvas.width, canvas.height, 0, 0, canvas.width, canvas.height);
    else for (let idx = 0; idx < board.length; ++idx) { // go through the board
        sx = (board[idx] % columns) * tile_w; // cell's contents indicate source location
        sy = Math.floor(board[idx] / columns) * tile_h;
        dx = (idx % columns) * tile_w; // cell's index indicates destination location
        dy = Math.floor(idx / columns) * tile_h; // next, handle blank tile (or draw tile)
        if (board[idx] === blank_ID && !success) ctx.fillRect(dx, dy, tile_w, tile_h);
        else ctx.drawImage(source, sx, sy, tile_w, tile_h, dx, dy, tile_w, tile_h);
        if (labels.checked) { // draw numbering labels
            let factor = canvas.width/canvas.clientWidth;
            ctx.fillStyle = '#FFFFFF';
            ctx.fillRect(dx, dy, 30*factor, 20*factor);
            ctx.fillStyle = '#000000';
            ctx.font = 20 * factor + 'px sans-serif';
            ctx.fillText(board[idx]+1, dx+2*factor, dy+18*factor);
        }
    }
}
function make_segments() {
    success = false;
    board = []; // just a vector, not 2D
    for (let r=0; r<rows; ++r) {
        for (let c=0; c<columns; ++c) { // persistent ID for shuffle and win check
            board.push(r*columns+c);
        }
    }
    blank_ID = board.pop();
    /* I specifically want the "missing" tile to be from the bottom right,
       to make it more visually pleasing to gradually solve the puzzle.
       and since that's known, the blank might as well also start at the bottom right */
    shuffleArray(board);
    /* now we count inversions.
       http://www.cs.bham.ac.uk/~mdr/teaching/modules04/java2/TilesSolvability.html
       an inversion is when a tile with a larger ID comes before a tile with
       a smaller ID - their order is "inverted." This is a factor in
       whether a given puzzle is solvable. */
    let inversions = 0;
    for (let tile = 0; tile < board.length; ++tile) {
        for (let subsequent = tile; subsequent < board.length; ++subsequent) {
            if (board[tile] > board[subsequent]) ++inversions;
        }
    }
    /* based on the way the blank tile is always the 'last' one, in the
       lower-right corner, we need an even number of inversions if we want
       this to be solvable. if it's odd, swap the last two elements */
    if (inversions % 2 === 1) [board[board.length-1], board[board.length-2]] = board.slice(-2);
    board.push(blank_ID); // don't forget to add the blank tile back after shuffling
    tile_h = canvas.height/rows;
    tile_w = canvas.width/columns;
}
function start_moving(event) {
    if (success) return;
    event.preventDefault();
    canvas.addEventListener('mousemove', move);
    move(event);
}
function start_touch(event) {
    if (success) return;
    event.preventDefault();
    canvas.addEventListener('touchmove', move);
    move(event);
}
function move(event) {
    if (success) return; // don't move after winning
    event.preventDefault();
    if (!(event.clientX && event.clientY)) { // jury-rig the correct offset, mock touch to mouse event
        let r = canvas.getBoundingClientRect();
        event.offsetX = event.targetTouches[0].clientX - r.left;
        event.offsetY = event.targetTouches[0].clientY - r.top;
    }
    // these max/min are necessary because the event coords can be outside the canvas, e.g. -1
    let x = Math.floor(columns * Math.max(0,
            Math.min(canvas.clientWidth-2, event.offsetX)) /
            canvas.clientWidth); // calculate clicked xy tile coords
    let y = Math.floor(rows * Math.max(0,
            Math.min(canvas.clientHeight-2, event.offsetY)) /
            canvas.clientHeight);
    let tile_idx = y * columns + x; // calculate corresponding index in board
    for (let [a, b] of [[-1, 0], [1, 0], [0, -1], [0, 1]]) { // neighbor tile locations
        // check that the neighbor is actually on the board, as the index calculation wouldn't complain
        if (!(0 <= x+a && x+a < columns && 0 <= y+b && y+b < rows)) continue;
        neighbor_idx = (y+b) * columns + (x+a) // calculate corresponding index in board
        if (board[neighbor_idx] === blank_ID) { // swap to that spot
            [board[tile_idx], board[neighbor_idx]] = [board[neighbor_idx], board[tile_idx]];
            lay_tiles();
            for (let idx = 0; idx < board.length; ++idx) if (idx !== board[idx]) return; // win check
            success = true;
            lay_tiles()
            break;
        }
    }
}
function stop_moving(event) {
    canvas.removeEventListener('mousemove', move);
}
function stop_touch(event) {
    canvas.removeEventListener('touchmove', move);
}
function toggle_playback() {
    video.paused ? video.play() : video.pause();
}
function step() { // update the canvas when a video proceeds to next frame
    lay_tiles();
    animation_handle = video.requestVideoFrameCallback(step);
}
function autoselect_dimensions(small, width, height) {
    let ratio = Math.max(width, height) / Math.min(width, height);
    let big = Math.round(small * ratio);
    if (width > height) [columns, rows] = [big, small];
    else [rows, columns] = [big, small];
}
function setdims() { // setup after loading a video
    if (autoselect) autoselect_dimensions(Math.max(rows, columns), video.videoWidth, video.videoHeight);
    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;
    make_segments();
    source = video;
    labels.onclick = lay_tiles;
    video.cancelVideoFrameCallback(animation_handle);
    step();
}
function waitForImageToLoad(imageElement){
  return new Promise(resolve=>{imageElement.onload = resolve});
}
function drop_file(event) { // open the dropped file
    event.preventDefault();
    chooser.files = event.dataTransfer.files;
    choose_file({'target':{'files':event.dataTransfer.files}});
}
function choose_file(event) { // open the chosen file
    let file = event.target.files[0];
    if (!file) return;
    let obj_url = URL.createObjectURL(file);
    if (video.canPlayType(file.type)) start_media(obj_url, 'video');
    else start_media(obj_url, 'image');
}
function choose_URL(kind) {
    try { new URL(address.value); }
    catch { return; } // if it's an invalid URL
    start_media(address.value, kind); // kind is either 'video' or 'image'
}
function start_media(obj_url, kind) {
    rows = parseInt(row_field.value);
    columns = parseInt(column_field.value);
    autoselect = false;
    if (rows < 3 && columns < 3) rows = columns = 3;
    else if (rows < 3 || columns < 3) autoselect = true;
    if (kind === 'video') start_video(obj_url);
    else start_image(obj_url);
}
function start_video(obj_url) {
    image.src = '';
    video.src = obj_url;
    video.addEventListener('loadeddata', setdims, false);
    play_button.style['display'] = 'inline';
}
function start_image(obj_url) {
    video.src = '';
    image.src = obj_url;
    video.removeEventListener('play', step);
    video.removeEventListener('loadeddata', setdims);
    waitForImageToLoad(image).then(()=>{
        if (autoselect) autoselect_dimensions(Math.max(rows, columns), image.width, image.height);
        canvas.width = image.width;
        canvas.height = image.height;
        make_segments();
        source = image;
        lay_tiles();
        labels.onclick = lay_tiles;
    });
    play_button.style['display'] = 'none';
}
canvas.ondrop = drop_file;
canvas.ondragover = canvas.ondragenter = function(evt) {
  evt.preventDefault();
}
chooser.onchange = choose_file;
canvas.addEventListener('mousedown', start_moving);
canvas.addEventListener('touchstart', start_touch);
document.addEventListener('mouseup', stop_moving);
document.addEventListener('touchend', stop_touch);
</script>
</body>

</html>